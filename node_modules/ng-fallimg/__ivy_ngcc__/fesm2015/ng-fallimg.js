import { Directive, ElementRef, Input, HostListener, Inject, NgModule } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Injector token constant that contains all the fallback sources
 */
/** @type {?} */
import * as ɵngcc0 from '@angular/core';
const NG_FALLIMG_SOURCES = 'NG_FALLIMG_SOURCES';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Directive for handling the default image when the main image doesn't works
 */
class NgFallimgDirective {
    /**
     *
     * @param {?} el ElementRef service
     * @param {?} fallimgSources Injector token that contains all the fallback sources
     */
    constructor(el, fallimgSources) {
        this.el = el;
        this.fallimgSources = fallimgSources;
    }
    /**
     * It handles the error when the main image doesn't load
     * @private
     * @return {?}
     */
    errorImgHandler() {
        // The chosen source
        /** @type {?} */
        const source = this.fallimgSources[this.fallimg || 'default'];
        // Verify if the key exists in all fallback sources
        if (!source) {
            throw new Error(`ng-fallimg error: ${this.fallimg} doesn't exist as a source or it is an empty source`);
        }
        // it checks if the charged source is different to the actual source, this avoid the infinite bucle creation
        if (source !== this.lastSource) {
            // It saves the last source for matching when the fallback source fails and retried, that avoid an infinite bucle
            this.lastSource = source;
            ((/** @type {?} */ (this.el.nativeElement))).src = source;
        }
    }
}
NgFallimgDirective.ɵfac = function NgFallimgDirective_Factory(t) { return new (t || NgFallimgDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NG_FALLIMG_SOURCES)); };
NgFallimgDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgFallimgDirective, selectors: [["img", "fallimg", ""]], hostBindings: function NgFallimgDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("error", function NgFallimgDirective_error_HostBindingHandler() { return ctx.errorImgHandler(); });
    } }, inputs: { fallimg: "fallimg" } });
/** @nocollapse */
NgFallimgDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [NG_FALLIMG_SOURCES,] }] }
];
NgFallimgDirective.propDecorators = {
    fallimg: [{ type: Input, args: ['fallimg',] }],
    errorImgHandler: [{ type: HostListener, args: ['error',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgFallimgDirective, [{
        type: Directive,
        args: [{
                selector: 'img[fallimg]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{
                type: Inject,
                args: [NG_FALLIMG_SOURCES]
            }] }]; }, { 
    /**
     * It handles the error when the main image doesn't load
     * @private
     * @return {?}
     */
    errorImgHandler: [{
            type: HostListener,
            args: ['error']
        }], fallimg: [{
            type: Input,
            args: ['fallimg']
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgFallimgModule {
    /**
     * @param {?} sources All the fallback sources
     * @return {?}
     */
    static forRoot(sources) {
        return {
            ngModule: NgFallimgModule,
            providers: [
                {
                    provide: NG_FALLIMG_SOURCES,
                    useValue: sources
                }
            ]
        };
    }
}
NgFallimgModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgFallimgModule });
NgFallimgModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NgFallimgModule_Factory(t) { return new (t || NgFallimgModule)(); } });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgFallimgModule, { declarations: [NgFallimgDirective], exports: [NgFallimgDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgFallimgModule, [{
        type: NgModule,
        args: [{
                declarations: [NgFallimgDirective],
                exports: [NgFallimgDirective]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NgFallimgModule, NG_FALLIMG_SOURCES as ɵb, NgFallimgDirective as ɵa };

//# sourceMappingURL=ng-fallimg.js.map